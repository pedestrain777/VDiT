# EDEN 贪婪细化插帧改进说明

## 📋 改进概述

本次改进实现了**动态决定插帧位置的贪婪细化算法**，将原来的"每段固定插1帧或3帧"改为"每次插1张中点帧，循环直到达到目标帧数（如24帧）"。

## 🔧 实现的功能

### 核心算法：Motion-Aware Greedy Refinement

- **输入**：初始帧序列（可以是全部帧或关键帧），目标帧数（如24）
- **过程**：
  1. 为每个相邻帧对计算"需要插帧"的分数（score）
  2. 使用最大堆（max-heap）存储所有区间，按分数排序
  3. 循环：取出分数最高的区间 → 插入中点帧 → 更新左右两段的分数
  4. 直到帧数达到目标长度

### 优势

- ✅ **灵活性**：可以从任意初始帧数开始（6、8、12...），最终都能达到24帧
- ✅ **精确控制**：每次只插1帧，不会被"1或3"的离散选择限制
- ✅ **自适应**：根据运动分数动态决定插帧位置，运动大的区域会优先被细化

## 📁 新增文件

### 1. `src/scheduler/greedy_refine.py`

通用的贪婪细化调度器，使用双向链表+最大堆实现。

**关键特性**：
- 使用 `Node` 类构建双向链表，维护帧序列
- 使用最大堆存储区间，按分数排序
- **懒惰删除**（lazy deletion）：插入新帧后，旧区间自动失效，pop时检查即可
- 完全模型无关：只需要传入 `score_fn` 和 `interp_fn` 回调

**函数签名**：
```python
def greedy_refine(
    frames: List[Any],              # 初始帧序列
    target_len: int,                # 目标帧数
    score_fn: Callable[[Any, Any], float],  # 打分函数
    interp_fn: Callable[[Any, Any], Any],   # 插帧函数
    max_iters: Optional[int] = None,
    verbose: bool = False,
) -> List[Any]
```

### 2. `src/scheduler/__init__.py`

包初始化文件，导出 `greedy_refine` 函数。

## 🔄 修改的文件

### 1. `client.py`（HTTP服务模式）

#### 新增函数：`compute_pair_score()`

为任意两帧计算"需要插帧"的分数：
- 全局运动：`1 - cosine_similarity(frame0, frame1)`
- 局部运动：top-k 像素差的平均值
- 融合：`alpha * 全局 + (1-alpha) * 局部`

#### 修改：`process_video()` 中的 `use_adaptive=True` 分支

**原来**：
```python
# 1. 计算所有区间的运动分数
motion_scores = compute_motion_scores(...)
# 2. 用中位数分两档：depth=1 或 depth=2
# 3. 递归插帧：depth=1插1帧，depth=2插3帧
```

**现在**：
```python
# 使用 greedy_refine：
refined = greedy_refine(
    init_frames,           # 初始帧（视频的全部帧）
    target_len=24,         # 目标：24帧
    score_fn=compute_pair_score,
    interp_fn=interpolate_http,
    verbose=True
)
```

### 2. `inference.py`（本地推理模式）

#### 新增函数：`compute_pair_score()`

与 `client.py` 中相同的实现。

#### 修改：视频处理中的运动分析+递归插帧部分

**原来**：
```python
# 2. 第一遍：运动分析（per-video 标准化 + 局部 top-k）
motion_scores = compute_motion_scores(...)
# 3. 第二遍：根据 depth 做递归插帧
for i in range(frames_num - 1):
    mids = recursive_interp(frame0, frame1, depth, ...)
```

**现在**：
```python
# 2) Greedy refine：直到 24 帧
refined = greedy_refine(
    init_frames,
    target_len=24,
    score_fn=compute_pair_score,
    interp_fn=lambda a, b: interpolate(a, b, use_split_gpu=args.use_split_gpu),
    verbose=True
)
```

## 🎯 使用方式

### client.py（HTTP模式）

```bash
# 自适应插帧模式（现在使用 greedy refine）
python client.py --video_path examples/0.mp4 --use_adaptive

# 固定插帧模式（每对帧之间固定插1帧，不使用greedy）
python client.py --video_path examples/0.mp4
```

### inference.py（本地模式）

```bash
# 单GPU模式（现在使用 greedy refine）
python inference.py --video_path examples/0.mp4

# 双GPU模式（现在使用 greedy refine）
python inference.py --video_path examples/0.mp4 --use_split_gpu
```

## 📊 算法对比

| 特性 | 原算法（depth=1/2） | 新算法（greedy refine） |
|------|-------------------|----------------------|
| 插帧决策 | 每段固定插1或3帧 | 每次插1帧，循环直到目标 |
| 初始帧数限制 | 受限于"1或3"的组合 | 任意帧数（6、8、12...） |
| 目标帧数控制 | 难以精确控制 | 精确达到目标帧数（如24） |
| 适应性 | 基于中位数的两档划分 | 基于堆排序的实时优化 |

## 🔍 技术细节

### 懒惰删除（Lazy Deletion）

堆中的区间可能在插入新帧后失效（不再相邻）。实现时：
- 不主动删除旧区间
- pop时检查：`left.next is right` 和版本号是否变化
- 失效的区间直接跳过，继续pop下一个

### 双向链表的版本控制

每个 `Node` 维护 `ver_next` 和 `ver_prev`：
- 插入新节点时，自动递增版本号
- heap中存储插入时的版本号快照
- 判断区间是否有效：版本号匹配 + 指针连接正确

### 时间复杂度

- 初始化：O(N log N) - N个区间入堆
- 每次插入：O(log N) - 插入新帧 + 2个新区间入堆
- 总复杂度：O(M log N)，M为目标插帧次数，N为当前帧数

## ⚠️ 注意事项

1. **初始帧数限制**：如果初始帧数 > target_len，会抛出 ValueError
   - 解决：先做关键帧采样，或增大 target_len

2. **计算资源**：greedy refine 需要多次调用插帧函数
   - 每次循环只插1帧，但可能需要多次循环
   - HTTP模式下会有多次网络请求

3. **向后兼容**：
   - `recursive_interp()` 函数仍然保留，但不再被使用
   - `compute_motion_scores()` 函数仍然保留，但只在非greedy模式下使用

## 🚀 下一步优化方向

1. **关键帧选择**：可以先从视频中选择关键帧作为初始序列，而不是使用全部帧
2. **评分函数优化**：可以集成RAFT光流、5信息融合等更复杂的评分机制
3. **并行化**：如果有多张GPU，可以并行处理多个区间的插帧

## 📝 文件变更清单

```
新增：
+ src/scheduler/greedy_refine.py          # 贪婪细化调度器
+ src/scheduler/__init__.py               # 包初始化文件

修改：
M client.py                               # 新增 compute_pair_score，修改 process_video
M inference.py                            # 新增 compute_pair_score，修改视频处理逻辑
```

## ✅ 验证

所有文件的语法检查已通过：
- ✓ `src/scheduler/greedy_refine.py` 语法正确
- ✓ `client.py` 语法正确
- ✓ `inference.py` 语法正确

代码已准备就绪，可以在eden环境中测试运行。

